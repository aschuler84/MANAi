<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, serif;
        }

        #orientationButtonContainer {
            position: absolute;
            top: 10px;
        }

        #modeButtonContainer {
            position: absolute;
            bottom: 10px;
        }

        #volumeInfoButton {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        button {
            width: 150px;
            height: 50px;
            margin: 10px;
            color: white;
            background: black;
            border: 1px solid white;
            cursor: pointer;
        }

        button:hover {
            color: black;
            background: white;
            border: 1px solid black;
        }

        .infoPanel {
            padding: 10px;
            border: 1px solid white;
            background: gray;
            position: absolute;
            font-size: 18px;
            color: white;
        }

        #axisInfo {
            margin: 10px;
            top: 70px;
        }

        #volumeInfo {
            margin: 10px;
            top: 70px;
            right: 10px;
            max-width:20%;
            max-height: 50%;
            overflow: auto;
            font-size: 14px;
        }

        #axisInfo #xInfo {
            background-color: red;
        }

        #axisInfo #yInfo {
            background-color: green;
        }

        #axisInfo #zInfo {
            background-color: blue;
        }
    </style>
</head>
<body>
    <div id="orientationButtonContainer" class="buttonContainer">
        <button id="xyButton">XY View</button>
        <button id="yzButton">YZ View</button>
        <button id="xzButton">XZ View</button>
        <button id="3dButton">3D View</button>
    </div>
    <div id="modeButtonContainer" class="buttonContainer">
        <button id="standardButton">Standard</button>
        <button id="centeredButton">Centered</button>
        <button id="xAlignedButton">X Aligned</button>
        <button id="yAlignedButton">Y Aligned</button>
        <button id="zAlignedButton">Z Aligned</button>
    </div>
    <button id="volumeInfoButton">Toggle Volume Info</button>
    <div id="axisInfo" class="infoPanel">
        <span id ="xInfo">X-Axis: Average Power [W]</span></br>
        <span id ="yInfo">Y-Axis: Frequency</span></br>
        <span id ="zInfo">Z-Axis: Average Runtime [ms]</span></br></br>
        <span>X*Y-Plane: Power [W]</span></br>
        <span>Y*Z-Plane: Runtime [ms]</span></br>
        <span>X*Z-Plane: Average Energy [J]</span></br></br>
        <span>X*Y*Z-Volume: Energy [J]</span>
    </div>
    <div id="volumeInfo" class="infoPanel"></div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.148.0/three.js"></script>
<script>
    let traces;
    let renderer, scene, camera;
    function setup() {
        var pieces = window.location.href.split("?");
        traces = jQuery.parseJSON(decodeURIComponent(pieces[1].substring(5)));

        for (let i = 0; i < traces.length; i++) {
            let currPower = traces[i].averagePower * traces[i].frequency;
            let currRuntime = traces[i].averageRuntime * traces[i].frequency;
            let currAverageEnergy = traces[i].averagePower * traces[i].averageRuntime;
            let currEnergy = currAverageEnergy * traces[i].frequency;

            $("#volumeInfo").append("<b>Volume "+(i+1)+"</b></br>"+
                "- Name: "+traces[i].name+"</br>"+
                "- Path: "+traces[i].path+"</br>"+
                "- Average Power: "+traces[i].averagePower+"W</br>"+
                "- Frequency: "+traces[i].frequency+"</br>"+
                "- Average Runtime: "+traces[i].averageRuntime+"ms</br>"+
                "- Power: "+currPower+"W</br>"+
                "- Runtime: "+currRuntime+"ms</br>"+
                "- Average Energy: "+currAverageEnergy+"J</br>"+
                "- Energy: "+currEnergy+"J</br><hr>");
        }

        const screenRatio = window.innerHeight / window.innerWidth;
        const width = getHighestAxisValue() * 5;
        const height = getHighestAxisValue() * 5 * screenRatio;
        const cLeft = width / -2;
        const cRight =  width / 2;

        const cTop = height / 2;
        const cBottom = height / -2;
        camera = new THREE.OrthographicCamera(cLeft, cRight, cTop, cBottom, -Math.pow(getHighestAxisValue(), 2), 1000);
        camera.position.z = 0;
        scene = new THREE.Scene();

        $("#xyButton").click(function() { setOrientation("xy"); });
        $("#yzButton").click(function() { setOrientation("yz"); });
        $("#xzButton").click(function() { setOrientation("xz"); });
        $("#3dButton").click(function() { setOrientation("all"); });

        $("#standardButton").click(function() { setMode("standard"); });
        $("#centeredButton").click(function() { setMode("centered"); });
        $("#xAlignedButton").click(function() { setMode("xAligned"); });
        $("#yAlignedButton").click(function() { setMode("yAligned"); });
        $("#zAlignedButton").click(function() { setMode("zAligned"); });

        $("#volumeInfoButton").click(function() { $("#volumeInfo").toggle() });

        drawAxisSystem(getHighestAxisValue());

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animation);
        document.body.appendChild(renderer.domElement);
    }

    function setMode(newMode) {
        if (newMode === "standard") {
            let currX = 0, currY = 0, currZ = 0;

            for(let i = 0; i < allVolumes.length; i++) {
                allTargetPosX[i] = currX + allVolumes[i].geometry.parameters.width / 2;
                allTargetPosY[i] = currY + allVolumes[i].geometry.parameters.height / 2;
                allTargetPosZ[i] = currZ + allVolumes[i].geometry.parameters.depth / 2;

                currX += allVolumes[i].geometry.parameters.width;
                currY += allVolumes[i].geometry.parameters.height;
                currZ += allVolumes[i].geometry.parameters.depth;
            }
        } else if (newMode === "centered") {
            let currPos = 0;

            for(let i = 0; i < allVolumes.length; i++) {
                let offset = 0;
                if (allVolumes[i].geometry.parameters.width < allVolumes[i].geometry.parameters.height && allVolumes[i].geometry.parameters.width < allVolumes[i].geometry.parameters.depth) {offset = allVolumes[i].geometry.parameters.width;}
                else if (allVolumes[i].geometry.parameters.height < allVolumes[i].geometry.parameters.depth) {offset = allVolumes[i].geometry.parameters.height;}
                else {offset = allVolumes[i].geometry.parameters.depth;}

                currPos += offset;

                allTargetPosX[i] = currPos - allVolumes[i].geometry.parameters.width / 2;
                allTargetPosY[i] = currPos - allVolumes[i].geometry.parameters.height / 2;
                allTargetPosZ[i] = currPos - allVolumes[i].geometry.parameters.depth / 2;
            }
        } else if (newMode === "xAligned") {
            let currX = 0;

            for(let i = 0; i < allVolumes.length; i++) {
                allTargetPosX[i] = currX + allVolumes[i].geometry.parameters.width / 2;
                allTargetPosY[i] = allVolumes[i].geometry.parameters.height / 2;
                allTargetPosZ[i] = allVolumes[i].geometry.parameters.depth / 2;

                currX += allVolumes[i].geometry.parameters.width;
            }
        } else if (newMode === "yAligned") {
            let currY = 0;

            for(let i = 0; i < allVolumes.length; i++) {
                allTargetPosX[i] = allVolumes[i].geometry.parameters.width / 2;
                allTargetPosY[i] = currY + allVolumes[i].geometry.parameters.height / 2;
                allTargetPosZ[i] = allVolumes[i].geometry.parameters.depth / 2;

                currY += allVolumes[i].geometry.parameters.height;
            }
        } else if (newMode === "zAligned") {
            let currZ = 0;

            for(let i = 0; i < allVolumes.length; i++) {
                allTargetPosX[i] = allVolumes[i].geometry.parameters.width / 2;
                allTargetPosY[i] = allVolumes[i].geometry.parameters.height / 2;
                allTargetPosZ[i] = currZ + allVolumes[i].geometry.parameters.depth / 2;

                currZ += allVolumes[i].geometry.parameters.depth;
            }
        }
    }

    let allMajorAxes = [];
    let allMinorAxes = [];
    function drawAxisSystem(length) {
        var spacing = 0.05 * length;

        allMajorAxes.push(drawAxis(-spacing, -spacing, -spacing, length, -spacing, -spacing, 0xff0000));
        allMajorAxes.push(drawAxis(-spacing, -spacing, -spacing, -spacing, length, -spacing, 0x00ff00));
        allMajorAxes.push(drawAxis(-spacing, -spacing, -spacing, -spacing, -spacing, length, 0x0000ff));

        allMinorAxes.push(drawAxis(-spacing, -spacing, -spacing, length, length, -spacing, 0xaaaaaa));
        allMinorAxes.push(drawAxis(-spacing, -spacing, -spacing, length, -spacing, length, 0xaaaaaa));
        allMinorAxes.push(drawAxis(-spacing, -spacing, -spacing, -spacing, length, length, 0xaaaaaa));
    }

    function getAxisSum (axis) {
        var sum = 0;

        for (let i = 0; i < traces.length; i++) {
            if (axis === "x") {
                sum += traces[i].averagePower;
            } else if (axis === "y") {
                sum += traces[i].averageRuntime;
            } else if (axis === "z") {
                sum += traces[i].frequency;
            }
        }

        return sum;
    }

    function getHighestAxisValue () {
        var averagePowerSum = getAxisSum("x");
        var frequencySum = getAxisSum("y");
        var averageRuntimeSum = getAxisSum("z");

        if (averagePowerSum >= averageRuntimeSum && averagePowerSum >= frequencySum) { return averagePowerSum; }
        else if (averageRuntimeSum >= frequencySum) { return averageRuntimeSum; }
        else { return frequencySum; }
    }

    function drawAxis(startX, startY, startZ, endX, endY, endZ, color) {
        const points = [];
        points.push(new THREE.Vector3(startX, startY, startZ));
        points.push(new THREE.Vector3(endX, endY, endZ));

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: color });
        const line = new THREE.Line(geometry, material);

        scene.add(line);
        return line;
    }

    function renderDiagram() {
        var highestEnergy = getHighestEnergy(traces);

        for (let i = 0; i < traces.length; i++) {
            var currentTrace = traces[i];
            var currentEnergy = getEnergyOfTrace(currentTrace);
            var currentColor = getRelativeColorOfTrace(currentEnergy, highestEnergy);

            addNewVolume(currentTrace.averagePower, currentTrace.averageRuntime, currentTrace.frequency, new THREE.Color(currentColor));
        }
    }

    function getHighestEnergy (traces) {
        var highestEnergy = 0;

        for (let i = 0; i < traces.length; i++) {
            var currentEnergy = getEnergyOfTrace(traces[i]);

            if (currentEnergy > highestEnergy) {
                highestEnergy = currentEnergy;
            }
        }

        return highestEnergy;
    }

    function getEnergyOfTrace (trace) {
        return trace.averagePower * trace.averageRuntime * trace.frequency;
    }

    function getRelativeColorOfTrace (currentEnergy, highestEnergy) {
        var score = currentEnergy / highestEnergy;

        var h = (1.0 - score) / 3;
        var s = 0.8;
        var l = 0.7;
        var r, g, b;

        if (s === 0) {
            r = l;
            g = l;
            b = l;
        } else {
            var hue2rgb = function hue2rgb(p, q, t){
                if(t < 0) t += 1;
                if(t > 1) t -= 1;
                if(t < 1/6) return p + (q - p) * 6 * t;
                if(t < 1/2) return q;
                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return "#"+[Math.round(r * 255).toString(16), Math.round(g * 255).toString(16), Math.round(b * 255).toString(16)].join("");
    }

    let allVolumes = [];
    let allTargetPosX = [], allTargetPosY = [], allTargetPosZ = [];
    let currX = 0, currY = 0, currZ = 0;
    function addNewVolume(scaleX, scaleY, scaleZ, color) {
        const mesh = addMesh(currX + scaleX / 2, currY + scaleY / 2, currZ + scaleZ / 2, scaleX, scaleY, scaleZ, color);
        addEdgeHighlight(mesh, currX + scaleX / 2, currY + scaleY / 2, currZ + scaleZ / 2, 0xffffff);

        allTargetPosX.push(mesh.position.x);
        allTargetPosY.push(mesh.position.y);
        allTargetPosZ.push(mesh.position.z);
        allVolumes.push(mesh);

        currX += scaleX;
        currY += scaleY;
        currZ += scaleZ;

        return mesh;
    }

    function addMesh (posX, posY, posZ, scaleX, scaleY, scaleZ, color) {
        const geometry = new THREE.BoxGeometry( scaleX, scaleY, scaleZ );
        const material = new THREE.MeshBasicMaterial();
        material.color = color;

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = posX;
        mesh.position.y = posY;
        mesh.position.z = posZ;
        scene.add(mesh);

        return mesh;
    }

    function addEdgeHighlight (cubeMesh, posX, posY, posZ, color) {
        const edgesGeometry = new THREE.EdgesGeometry(cubeMesh.geometry, 40);
        const linesGeometry = new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: color}));

        scene.add(linesGeometry);
        cubeMesh.add(linesGeometry);
    }

    let camTargetPos = new THREE.Vector3(0, 0, 0);
    let camTargetRot = new THREE.Quaternion(0, 0, 0, 0);
    function animation(time) {
        // mesh movement
        var volumeSpeed = 1.0;

        for (let i = 0; i < allVolumes.length; i++) {
            let currVolume = allVolumes[i];
            let meshTargetPos = new THREE.Vector3(allTargetPosX[i], allTargetPosY[i], allTargetPosZ[i]);

            let difference = meshTargetPos.clone().sub(currVolume.position);
            if (difference.length() > 0.5) {
                currVolume.position.addScaledVector(difference.clone().normalize(), volumeSpeed);

                difference = currVolume.position.clone().sub(meshTargetPos);
                if (difference.length() <= 1.0) {
                    currVolume.position.set(meshTargetPos.x, meshTargetPos.y, meshTargetPos.z);
                }
            }
        }

        // camera movement
        var cameraMovementSpeed = 1.0;

        let camPosDifference = camTargetPos.clone().sub(camera.position);
        if (camPosDifference.length() > 0.5) {
            camera.position.addScaledVector(camPosDifference.clone().normalize(), cameraMovementSpeed);

            camPosDifference = camera.position.clone().sub(camTargetPos);
            if (camPosDifference.length() <= 1.0) {
                camera.position.set(camTargetPos.x, camTargetPos.y, camTargetPos.z);
            }
        }

        // camera rotation
        let cameraRotationSpeed = 0.05;

        let newRotation = new THREE.Quaternion();
        newRotation.setFromEuler(camera.rotation);
        newRotation.rotateTowards(camTargetRot, cameraRotationSpeed);
        camera.rotation.setFromQuaternion(newRotation);

        renderer.render(scene, camera);
    }

    function setOrientation(orientation) {
        for (let i = 0; i < allMinorAxes.length; i++) {
            allMinorAxes[i].visible = true;
        }

        if (orientation === 'xy') {
            allMinorAxes[1].visible = false;
            allMinorAxes[2].visible = false;
            camTargetPos = new THREE.Vector3(getAxisSum("x") / 2, getAxisSum("y") / 2, 0);
            camTargetRot.setFromEuler(new THREE.Euler(0, 0, 0));
        } else if (orientation === 'yz') {
            allMinorAxes[0].visible = false;
            allMinorAxes[1].visible = false;
            camTargetPos = new THREE.Vector3(0, getAxisSum("y") / 2, getAxisSum("z") / 2);
            camTargetRot.setFromEuler(new THREE.Euler(90*Math.PI/180, 90*Math.PI/180, 0));
        } else if (orientation === 'xz') {
            allMinorAxes[0].visible = false;
            allMinorAxes[2].visible = false;
            camTargetPos = new THREE.Vector3(getAxisSum("x") / 2, 0, getAxisSum("z") / 2);
            camTargetRot.setFromEuler(new THREE.Euler(90*Math.PI/180, 180*Math.PI/180, 90*Math.PI/180));
        } else if (orientation === 'all') {
            camTargetPos = new THREE.Vector3(0, 0, 0);
            camTargetRot.set(-0.2798482, 0.3647052, 0.1159169, 0.8804763);
        }
    }

    setup();
    renderDiagram();
    setOrientation("xy");
</script>
</html>